---
layout: post
title:  "MySQL中的MyISAM和InnoDB"
subtitle:  " \"MySQL engine\""
date:   2017-8-22 16:29:18 +0800
tags:
    - MySQL
author: Nian Tianlei
header-img: "img/post-bg-os-metro.jpg"
header-mask: 0.4
catalog:    true
---

> 向下滑动查看更多内容.


MySQL支持不同的存储引擎，主要使用的有MyISAM和InnoDB。
## MyISAM  
MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。它是MySQL默认的存储引擎。5.5开始默认引擎改为InnoDB。  
<p style="font-size: 20px; font-weight: bold; color: #09f">特性</p>
1) 不支持事务和外键，宕机会破坏表。  
2) 使用较小的内存和磁盘空间，批量插入速度快。  
3) 基于表的锁，在处理并发上，在读取数据时，所有的表上都可以获得共享锁，每个连接互不干扰，而在写数据的时候，会获得排他锁，会对整个表进行加锁，其他的请求包括读和写都必须处于等待状态。因此，适于大部分是读操作的应用。  
4) 支持全文索引  
5) 支持三种不同的存储格式，它们分别是静态格式、动态格式和压缩格式。静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。  
6) 采用非聚集索引，叶节点的数据区存放的是数据记录的地址。  
<p style="font-size: 20px; font-weight: bold; color: #09f">优化</p>
`key_buffer_size`-用来存放索引区块的缓存值，一般128M以上且不大于内存的30%。  
`sort_buffer_size`-设置、修改表的时候使用的缓存大小，不要设太大。  
`read_buffer_size`-用来全表扫描的缓冲大小，为从数据表顺序读取数据的读操作保留的缓存。16M。  
`myisam_max_[extra]_sort_file_size`足够大，显著提高repair table的速度。  


**适于读多写少、批量导入数据、没有事务的低并发读/写、全表扫描等。**

## InnoDB
InnoDB给MySQL提供了具有提交，回滚和崩溃恢复能力的事务安全（ACID）存储引擎。在SQL查询中，可以自由地将InnoDB类型的表与其它MySQL的表的类型混合起来，甚至在同一个查询中也可以混合。
InnoDB是为在处理巨大数据量时获得最大性能而设计的。它的CPU使用效率非常高。
InnoDB存储引擎已经完全与MySQL服务器整合，InnoDB存储引擎为在内存中缓存数据和索引而维持它自己的缓冲池。 InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何大小，即使在文件尺寸被限制为2GB的操作系统上。
<p style="font-size: 20px; font-weight: bold; color: #09f">特性</p>
1) 支持事务和外键，支持不同的隔离级别。支持ACID，由redo, undo log实现。默认使用可重复度的隔离级别，因为使用next-key lock所以不会出现幻读。    
2) 行级锁。     
3) 和MyISAM相比需要较多的内存和磁盘空间。  
4) 不支持全文索引。  
5) 支持数据缓存和索引缓存。  
6) 采用聚集索引，叶结点的数据区保存了完整的数据记录，索引的key就是数据表的主键。如果没有主键，第一个唯一非空索引被作为聚集索引。  
聚集索引查询快，但插入较慢，且主键更改的开销很大。  
7) 自适应哈希。监控表上各索引页的查询，如果建立哈希索引会提升速度则建立。  
8) MVCC。读已提交/可重复读下使用，不需要锁，提高并发性能。  
<p style="font-size: 20px; font-weight: bold; color: #09f">优化</p>
尽量使用较小的主键如short，integer  
`innodb_buffer_pool_size`-使用缓冲池来保存索引和原始数据，设置越大在存取表中数据时磁盘I/O越少。可设为内存的60%。  
`innodb_log_buffer_size`-磁盘速度是很慢的，直接将log写道磁盘会影响InnoDB的性能，该参数设定了log buffer的大小，一般4M。如果有大的blob操作，可以适当增大。  
`innodb_log_file_size`-该参数决定了recovery speed。太大的话recovery就会比较慢，太小了影响查询性能，一般取256M可以兼顾性能和recovery的速度。  
`innodb_flush_logs_at_trx_commit=0`-日志缓冲每秒一次地被写到日志文件，并且对日志文件做到磁盘操作的刷新。任何mysqld进程的崩溃会删除崩溃前最后一秒的事务。  
避免主键更新，因为这会带来大量的数据移动。  

**适于需要事务的应用、读写频繁的场景、高并发的应用、较多基于主键操作的应用。**

## ACID
下面讲诉数据库中事务的四大特性（ACID），并且将会详细地说明事务的隔离级别。

如果一个数据库支持事务操作，必须具备这四个特性。

<span style="color: #3261e2; font-weight: bold; font-size: 17px;">(1)原子性（Atomicity）</span>  
　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要全部提交到数据库，如果操作失败则不能对数据库有任何影响。

<span style="color: #3261e2; font-weight: bold; font-size: 17px;">(2)一致性（Consistency）</span>  
　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态。事务开始和结束之间的中间状态不会被其他事务看到

　　例如：假设有五个账户，每个账户有100元余额，那五个账户总额是500元，如果在这5个账户之间同时发生多个转账，无论其中并发多少个操作，比如在A与B账户之间转账20元，在C与D账户之间转账30元，在B与E之间转账40元，五个账户总额应该还是500元。 

<span style="color: #3261e2; font-weight: bold; font-size: 17px;">(3)隔离性（Isolation）</span>  
　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。也就是串行化，使得在同一时间仅有一个请求用于同一数据。

　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。


<span style="color: #3261e2; font-weight: bold; font-size: 17px;">(4)持久性（Durability）</span>  
　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

### 隔离性
　　然后重点来说下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：

**1.脏读**  
　　脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。


**2.不可重复读**  
　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。
例如：事务1两条`SELECT user_name FROM users WHERE id=1;`第一条得到原*user_name="tianlei"*。在间隔，事务2更新`update user set user_name = 'tyler' where user_id = 1`，事务2提交，事务1再查询得到*user_name="tyler"*。就是不可重复读。  
　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。


**3.虚读(幻读)**  
　　幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

 
### 四种隔离级别：

① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。事务按串行化顺序执行。

② Repeatable read (可重复读)：InnoDB默认的事务隔离级别。可避免脏读、不可重复读的发生。开始读取数据（事务开启）时，不再允许修改操作

③ Read committed (读已提交)：可避免脏读的发生。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。

④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。就是一个事务可以读取另一个未提交事务的数据。如果一个事务已经开始写数据，仍然允许其他事务读此行数据。

 

　　以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。

　　在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。

后记：设置数据库的隔离级别一定要是在开启事务之前！
隔离级别的设置只对当前链接有效!!!

