---
layout:     post
title:      "分布式一致性协议"
subtitle:   " \"conformance protocol in distributed system\""

author:     "Nian Tianlei"
header-img: "img/post-bg-2016.jpg"
header-mask: 0.4
catalog:    true
tags:
    - 分布式
---

## 分布式系统  
*分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。*   

分布式系统中的多台计算机都会在空间上随意分布，同时，机器的分布情况也会随时变动。  
分布式系统中的计算机没有主从之分，即组成系统的所有计算机节点都是对等的。而如果一台服务器崩溃，就可能导致服务不可用。为解决这一难题，往往会增加冗余性，在一台服务器不可用的时候，有备用机器。从而对外提供高可用的服务。  

分布式系统中存在多个节点，可能会并发地访问操作一些共享资源，如何保证数据一致性称为分布式系统架构设计中的另一难题。  

## 事务  
事务具有ACID特性，防止彼此之间的操作互相干扰。事务为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保证数据一致性的方法。  

标准SQL规范中，定义了4个不同的事务隔离级别，不同的隔离级别对事务的处理不同，从低到高分别是read uncommitted、read committed、repeatable read、serializable。  

MySQL中的InnoDB引擎中，存在多版本并发控制，即MVCC，read committed和repeatable read两个级别的实现就基于此。  
而MVCC中不同版本的数据就储存在redo log中。事务过程中会将数据保存在redo log和undo log中，这个是InnoDB引擎的常用知识，不再细说。  

## 分布式事务
事务在分布式计算领域中也得到了广泛的应用。单机环境中，很容易保证一致性，实现ACID特性的事务处理系统不难；但在分布式数据库中，数据分布在不同的机器上，对这些数据进行分布式的事务处理就非常有挑战性。  

例如：跨行异地转账，可分为本银行的取款，目标银行的存款两个步骤。这两个服务本身是无状态且独立的，共同构成了一个完整的分布式事务。两个步骤任一步发生异常服务失败，那么就必须回滚到取款前的状态，否则数据就出现不一致的状态，那客户的钱就不知道去哪里了。  

一个分布式事务可看作是多个分布式的操作序列组成，或者称为多个子事务。如何保证分布式事务的ACID就极富有挑战性。  

## CAP理论
对于高访问、高并发的互联网分布式系统来说，很期望实现严格满足ACID特性的分布式事务。但事实上，很难设计出同时满足高可用和强一致的分布式系统。于是出现CAP理论。  

**CAP理论：**一个分布式系统不可能同时满足一致性（C:Consistency）、可用性（A:Availability）和分区容错性（P:Partition tolerance）这三个基本需求，最多只能其中两项。  

#### 一致性
**强一致性：**分布式系统中，如果能够一个数据的更新操作执行成功后，所有的用户都可以读取到其最新的值。    
**强一致性：**分布式系统中，如果能够一个数据的更新操作执行成功后，所有的用户都可以读取到其最新的值。  
#### 可用性
系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在**有限的时间**内返回**正确结果**。  
超过这个时间范围，就可以认为是不可用的。比如，对于一次搜索，几十秒才返回搜索结果，能坚持使用的用户应该不会太多。  
另一方面，返回结果不能错误，否则对于用户没有价值，也是不可用的。  

#### 分区容错性
分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。  



CAP理论要求：  
- 将所有数据放到一个分布式节点上，可保证一致性，及分区容错性，但放弃多机扩展的同时也不能保证可用性，机器异常则整个系统崩溃。  
- 如果保证可用性A，各节点可独自处理请求，但由于网络不通不能同步数据，必然会导致数据的不一致，只能保证AP。  
- 单机只能保证CA  

## BASE理论  
BASE即基本可用Basically、软状态Soft state、Eventually consistent最终一致性。  
BASE是对CAP中一致性和可用性权衡的结果，其来源对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，核心思想是即使无法做到强一致性，但应用可根据业务特点，采用适当的方式来使系统达到最终一致性。  

#### 基本可用
系统在出现故障时，允许损失部分可用性。  
**响应时间**：服务可能因为某种故障响应时间稍微增加。  
**功能**：服务降级等。  

#### 弱状态
允许系统中的数据存在中间状态，且该状态不会影响系统的整体可用性。  

#### 最终一致性
系统中的所有数据副本，经过一段时间的同步后，最终能够达到一个一致的状态。不需保证强一致性。  



## 一致性协议
未解决分布式一致性问题，著名的算法有二阶段提交协议、三阶段提交协议和Paxos算法。  

#### 2PC
在分布式系统中，每台机器都清楚知道自己在进行事务操作过程中的结果是成功或失败，但却无法直接获取到其他分布式节点的操作结果。  
因此，当一个事务操作需要跨越多个分布式节点的时候，又想保证事务ACID的特性，需要引入一个“协调者”组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点称为“参与者”。  
协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。  

2PC，即二阶段提交。  
**阶段一：提交事务请求**  
1.事务询问  
协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。  
2.执行事务  
各参与者节点执行事务操作，并将undo、redo信息写到事务日志中。  
3.参与者向协调者反馈事务询问响应  
如果参与者成功执行了事务操作，会反馈给协调者一个成功响应，表示事务可以执行通过；如果参与者没有成功执行事务，那么就反馈给协调者失败响应，表示事务不能执行。  


**阶段二：执行事务提交**  
在这个阶段，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作。  
包含执行事务提交和 中断事务两种可能。  

*执行事务提交*   
要求所有参与者返回成功响应  
1.发送提交请求。协调者向所有参与者节点发出commit请求。  
2.事务提交。参与者收到commit请求后，会正式执行事务提交操作。  
3.反馈事务提交结果。参与者在完成事务提交后，向协调者发送ACK消息。  
4.完成事务。协调者接收到所有参与者的ACK反馈消息后，完成事务。  


*中断事务*  
如果有任何一个参与者向协调者反馈了失败响应，或者超时后，协调者仍未收到所有参与者的反馈响应，那么就会中断事务。  
1.发送回滚请求。协调者向所有参与者节点发出Rollback请求。  
2.事务回滚。参与者接收到Rollback请求后，会利用其在阶段一中记录的undo信息来执行事务回滚操作。  
3.反馈事务回滚结果。参与者在完成事务回滚后，向协调者发送ACK消息。  
4.中断事务。协调者收到所有参与者反馈的ACK消息后，完成事务中断。  

总的来说，2PC将事务的处理过程分为投票和执行两个阶段，核心是每个事务都采用先尝试后提交的处理方式，因此可看作是强一致性的算法。  



#### 2PC优缺点分析
2PC实现简单，原理也简单。但缺点也很明显：同步阻塞，单点问题，数据不一致，过于保守。  

同步阻塞：在二阶段提交过程中，所有参与该事务操作的逻辑都处于阻塞状态，即各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作。  

单点问题：协调者在2PC中起了非常重要的作用。一旦协调者出问题，整个二阶段提交将会破坏。如果协调者在阶段二出现问题，其他参与者可能会一直处于锁定事务资源的状态中，而无法继续完成事务操作。  

数据不一致：在阶段二，协调者向所有参与者发完commit请求后，发生了局部网络异常或尚未发送完commit请求之前自身发生崩溃，导致最终只有部分参与者收到了commit请求。这部分参与者就会进行事务提交，而其他参与者无法提交事务，于是系统就出现数据不一致的现象。  

过于保守：参与者出现故障，协调者得不到响应，这是只能依靠超时机制判断，过于保守。  


#### 3PC
3PC，三阶段提交，是2PC的改进版，将二阶段提交的“提交事务请求”过程分为两步。形成CanCommit, PreCommit, do Commit三个阶段组成的事务处理协议。  

**阶段一：CanCommit**  
1事务询问。协调者向所有参与者发送包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。  
2各参与者向协调者反馈事务询问的响应。如果参与者认为自己可以顺利执行事务，反馈yes响应，进入预备态，否则反馈no响应。  
  
**阶段二：PreCommit**  
根据参与者的反馈有两种可能，反馈中有no响应或超时则中断事务：  

*执行事务预提交*  
1发送预提交请求。协调者向所有参与者发出preCommit请求，并进入Prepared阶段。  
2事务预提交。参与者收到preCommit请求后，执行事务操作，并将undo和redo信息写入事务日志。  
3各参与者向协调者反馈事务执行的响应。如果参与者成功执行了事务操作，那么就会反馈给协调者ACK响应。  

*中断事务*  
1发送中断请求。协调者向所有参与者发出abort请求。  
2中断事务。参与者收到abort请求或等待超时，都会中断事务。  

**阶段三：doCommit**  
*事务提交*  
1发送提交请求。协调者收到所有的ACK响应，会发送do Commit请求。  
2事务提交。参与者收到do Commit请求，会正式提交事务。  
3反馈事务提交结果。参与者完成提交后，向协调者发送ACK消息。  
4完成事务。  

*中断事务*  
协调者向所有参与者发送abort请求。  
参与者利用undo信息进行回滚，回滚完成后，向协调者发送ACK消息。  
协调者收到所有参与者反馈的ACK消息后，中断事务。  


#### 3PC优缺点分析
3PC最大的优点就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。  

缺点是：参与者收到preCommit消息后，如果网络出现故障，参与者依然会进行事务的提交，会出现数据的不一致性。  


## Paxos算法
